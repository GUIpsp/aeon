one : Integer = 1;


(&&) : (a:Boolean) -> (b:Boolean) -> {c:Boolean where (c === (a && b))} = native;


a : Integer = [[Integer]];
b : Boolean = [[Boolean]];
c : (p:Integer) -> Integer = [[(q:Integer) -> Integer]];
d : (r:Boolean) -> Integer = [[(s:Boolean) -> Integer]];
e : (t:Integer) -> Boolean = [[(u:Integer) -> Boolean]];
f : {v:Integer where (v > 3)} = [[{x:Integer where (x > 3)}]];
g : (T:*) => Boolean = [[(T:*) => Boolean]];

h : Integer = [[{h1:Integer where (h1 > 7)}]];



test : (T:*) => Boolean = (T:*) => True;




public <T> Boolean tentar(T a) {
  return True;
}


tentar : (T:*) => Boolean = (T:*) => True

AbstractionType(
  x, BasicType("String"),
  RefinedType(z, BasicType(String), [x > z])
)




Map<String, X>

X:* => ((Map<String>)<X>)

TypeAbstraction (X, star,
  TypeApp( 
    TypeApp(Map, String)
  , X )
)

1 + 1;
x;
2


let _:Int = 1+1 in
let _:X = x in
2


(\_:Int ->   (\_:Top -> 2 * x )(x)      )(1+1)

























