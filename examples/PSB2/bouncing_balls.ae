# Given a starting height and a height after the first
# bounce of a dropped ball, calculate the bounciness
# index (height of first bounce / starting height).
# Then, given a number of bounces, use the bounciness
# index to calculate the total distance that the ball
# travels across those bounces.
# input : float in [1.0, 100.0], float in [1.0, 100.0], integer in [1, 20]
# output : float
# -- working --

import Math;
type Unit;

def math : Unit = native_import "math";

# ['1.001', '1.0', '1'], ['2.001']

#constants
def constant_f0 : Float = 0.0;
def constant_f1 : Float = 1.0;
def constant_f2 : Float = 2.0;


def bouncing_balls : (starting_height: {x:Float | 1.0 <= x && x <= 100.0} ) -> ( bounce_height:{y:Float | 1.0 <= y && y <= 100.0} ) -> ( bounces:{z:Int | 1 <= z && z <= 20}) -> Float =
   # \a -> \b-> \c -> Math_toFloat (2 * Math_toInt(a) * (1 - Math_pow (Math_toInt(b /. a)) c ) / Math_ceil(1.0 -. (b /. a)));
    native "lambda x: lambda y: lambda z: x + 2 * y * (1 - math.pow((y / x), z)) / (1 - y / x)";


def main (i: Int) : Unit { print( bouncing_balls 1.001 1.0 1) }

# def synth  (a:{x:Float | 1.0 <= x && x <= 100.0} , b:{y:Float | 1.0 <= y && y <= 100.0} ,  c:{z:Int | 1 <= z && z <= 20}) : Float {
#   (?hole:Float)
# }
