import ..prelude.J
import ..prelude.S


# Ele corre mas chega a uma solucao cujo valor eh errado <------------- Rever condicoes
# Problema: Math.abs((Double.valueOf(1.0) * (__return_0 - ((
# Problema 2: Eh necessario comentar o concat do prelude.S para que o espaco de procura seja mais pequeno
# Comparacao de booleans nao funciona. FitnessEvaluator aplica a formula


andOperator : (b1:Boolean, b2:Boolean) -> b:Boolean where [(J.id(b) && (b1 && b2)) || (!id(b) && !(b1 && b2))] {
    b1 && b2
}

smallerThan : (s1:String, s2:String) -> b:Boolean where [b == (S.size(s1) < S.size(s2)) ] {
    S.size(s1) < S.size(s2)
}

# Nao funciona a seguinte restricao: res == ((S.size(s1) < S.size(s2)) && (S.size(s2) < S.size(s3)))
compareStringLength : (s1:String, s2:String, s3:String) -> res:Boolean where [(res && ((S.size(s1) < S.size(s2)) && (S.size(s2) < S.size(s3)))) ||
                                                                             (!res && ((S.size(s2) < S.size(s1)) || (S.size(s3) < S.size(s2))))] {
   â€¦
   #b1 : Boolean = smallerThan(s1, s2)
   #b2 : Boolean = smallerThan(s2, s3)
   #andOperator(b1, b2)
}


main : (_:Array<String>) -> _:Void {

    s1 : String = "Hey"
    s2 : String = "Lets"
    s3 : String = "Benchmark"

    J.out(compareStringLength(s1, s2, s3))
}
