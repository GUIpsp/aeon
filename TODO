automatic:
    ✔ error when generating a program with no input method parameters @done(20-05-09 19:12)
    ☐ restrict the genetic information in the genetic pool @low
        we add to much information to the genetic pool. Perhaps restricting the
        information and only allowing subtrees that do not exist will improve the 
        evolution
    ☐ edge case tests in individuals evaluation
    ☐ try energy consumption optimization
    ☐ evaluate the continuous fitness functions
    ☐ change forall and exists to sum and minimum, respectively
    ✔ make tests stop after 5 seconds @started(20-05-09 19:21) @done(20-05-09 19:33) @lasted(12m22s)
        way to do this
        @link(https://stackoverflow.com/questions/492519/timeout-on-a-function-call)
    ✔ I suspect I forgot to update the evaluation context with the program functions @done(20-05-09 19:12)
        sometimes a random error raises in the interpreter when evaluating the program
        Exception: function not in context
    ☐ optimization of the synthesized code

synthesis:
    ☐ change synthesis refinements based on trials to continuous synthesis @critical
        currently the synthesis is based on trials in order to synthesize programs
        this can be problematic when generating expressions from really restrictive
        types. Using interval arithmetic will allow us to continuously synthesize
        the programs
    ☐ sometimes generates expressions that do not typecheck
        error: z3.z3types.Z3Exception: True, False or Z3 Boolean expression expected. Received 260
    ☐ probabilities of the synthesis configurations

typechecker:
    ☐ if restrictions are not properly propagated 
        in some situations the conditions are not taken into consideration in 
        the refinements (e.g. function call with input restricted on if condition)
        Check the @file aeon/examples/benchmark/bench3.ae
    ☐ update zed interface using pysmt 
        This might be a slower solution since it introduces a new layer, but allows us
        to expriment different SMT's 
        @link(https://github.com/pysmt/pysmt)
    ☐ the uninterpreted functions are not being updated
        for some reason, the uninterpret function restrictions are not checked
        by the SMT
        @file examples/aeon3/strings.ae

libraries:
    ✔ add function conversion from int to float @done(20-05-10 19:06)
    ✔ uninterpreted function for `String` size @done(20-05-10 19:09)
    ✔ default function for `Void` that is `None` @done(20-05-10 19:18)
    ☐ bug in the power[X, Y] 
    ✔ improve refinements of String methods @done(20-05-10 19:35)
    ☐ `String` and `List` have the same method names.
        We should either add module that renames method names and allows overloading,
        or, allow shadowing, or, raise exception when this happens
    ☐ include the libraries: `Map`, `Tree`, `IO` and `Text`
    ☐ automatically generate the documentation
    ☐ create the annotation for documentation
    

frontend:
    ✔ refine strings in frontend @done(20-05-10 22:59)
    ☐ update hole notation to `??` and `?Integer?`
    ☐ problem with `-->` priority
    ☐ ghost_variables new parameter in TypeDeclaration
        the ghost_variables was introduced, no information about what to do with it...
    ☐ update the notation of TypeApplications and TypeAbstractions to `Type[T]` and `Type[Type]`
    
    language verifiers: 
        ☐ import cycles
        ☐ undeclared variables and functions
        ☐ undeclared types
        ☐ integer and double bounds
        ☐ raise warning when conditions are always true/false

    ☐ migrate to Lark

compiler:
    ☐ compile the code to Java

others:
    ☐ inference of the hole @high 
        this can be done after typechecking
    ☐ inference of type applications
    ☐ Translator from AeonCore to Aeon
    ☐ update syntax highlighter (create a new git)

bugs:
    ☐ typechecker is not checking uninterpreted refinements (@file aeon/examples/aeon3/list_demo.ae)
    ☐ not properly generating restricted type values for uninterpreted functions


===============================================================================
Done: