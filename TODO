automatic:
    ☐ restrict the genetic information in the genetic pool @low
        we add to much information to the genetic pool. Perhaps restricting the
        information and only allowing subtrees that do not exist will improve the 
        evolution
    ☐ edge case tests in individuals evaluation
    ☐ try energy consumption optimization
        @link(https://pypi.org/project/energyusage/) only works in linux
    ☐ evaluate the continuous fitness functions
    ☐ change forall and exists to sum and minimum, respectively
    ☐ changed the [(context, holes)] in typing, should change the invocations over genetics  @high
    ☐ optimization of the synthesized code

synthesis:
    ☐ change synthesis refinements based on trials to continuous synthesis @critical
        currently the synthesis is based on trials in order to synthesize programs
        this can be problematic when generating expressions from really restrictive
        types. Using interval arithmetic will allow us to continuously synthesize
        the programs
    ☐ se_string change the probability distribution of string sizes
    ☐ sometimes generates expressions that do not typecheck
        error: z3.z3types.Z3Exception: True, False or Z3 Boolean expression expected. Received 260
    ☐ probabilities of the synthesis configurations
    
    ranges:
        ✔ need a better way of obtaining the se_where variable name we are trying to synthesize @done(20-05-30 11:25)
            added static member to RangedContext
        ✔ filter non-restricted refinements from the context.refinements @done(20-05-31 17:27)
            be careful: we dont want to filter the uninterpreted functions
        ☐ convert expression to the CNF form
        ☐ convert each condition to force the variable on the right side
            Restrictions should suffer a conversion: x + x > 2    =>    2 * x > 2    =>    x > 1 
        ☐ interpret and replace uninterpreted values on conditions
            call the SMT and replace the invocations to uninterpreted functions with the values
        ☐ implement the vars and strings
        ☐ `&&` and `||` not working with bools
            or have different probabilities
        ✔ flatten refinements @done(20-05-31 17:47)
        ☐ Deal with non-continuous ranges
        ☐ Call SMT-Solver in case we are not able to synthesize the 
        ✘ need semantic analysis to obtain the values for the variables? @cancelled(20-05-30 10:47)
            The only information currently available is obtained from restrictions. The following
            example would not work since we have no information...
            No need: Just get the variable type from the context.variables and extract the ranges
        ☐ interesting examples of literal refinements synthesis against the SMT Solver
            compare with ranges and without ranges

typechecker:
    ✔ include assertions in rules to ensure implementation correctness @done(20-05-24 19:40)
    ☐ if restrictions are not properly propagated 
        in some situations the conditions are not taken into consideration in 
        the refinements (e.g. function call with input restricted on if condition)
        Check the @file aeon/examples/benchmark/bench3.ae
    ☐ update zed interface using pysmt
        This might be a slower solution since it introduces a new layer, but allows us
        to expriment different SMT's 
        @link(https://github.com/pysmt/pysmt): Only CVC4 handles strings, z3 doesn't ()
        Strings can be converted to an array of integers though...
    ☐ the uninterpreted functions are not being checked
        for some reason, the uninterpret function restrictions are not checked
        by the SMT
        check kinding
        @file examples/aeon3/strings.ae
        @file aeon/examples/aeon3/list_demo.ae

    improve error messages:
        ☐ improve node and error messages readability
            already added the translator to improve the messages. Need to improve it further
            by adding more explicit information about the kind of error 
        ☐ add line number and line where the error occurs

libraries:
    ✔ bug in the power[X, Y] @done(20-05-21 10:49)
    ☐ `String` and `List` have the same method names.
        We should either add module that renames method names and allows overloading,
        or, allow shadowing, or, raise exception when this happens
    ☐ include the libraries: `Map`, `Tree`, `IO` and `Text`
    ☐ automatically generate the documentation
    ✔ create the annotation for documentation @done(20-05-21 10:05)
    
frontend:
    ✔ update hole notation to `??` and `?Integer?` @done(20-05-21 10:07)
    ☐ problem with `-->` priority
    ✔ ghost_variables new parameter in TypeDeclaration @done(20-05-21 11:05)
        the ghost_variables was introduced, no information about what to do with it...
    ✔ update the notation of TypeApplications and TypeAbstractions to `Type[T]` and `Type[Type]` @done(20-05-21 10:08)
    ☐ if the last instruction is a definition, it doesnt assign the value and it doesnt typecheck properly
        if the last instruction is of the kind: x:Integer = true; the frontend
        only takes the body and ignores the rest of the assignment. We cannot
        ensure type correctness in this case

    language verifiers: 
        ☐ import cycles
        ☐ undeclared variables and functions
        ☐ undeclared types
        ☐ integer and double bounds
    
    aeoncore:
        ☐ wrong precendence of the boolean operators
        example: {x:Integer where x == 0 || (x > 5 && x <= 30)}  ~~~~~> ((== x) ((|| 0) ....))
        ☐ problem with parenthesis

    ☐ migrate to Lark

compiler:
    ☐ compile the code to Java

translator:
    ☐ doesnt work properly when the last instruction is the application of an abstraction
        if the functions ends with: (\x : T -> x + 1)(1) then the translation
        doesnt work properly 
    ☐ missing typeabstractions in the type in TypeDeclaration

interpreter:
    ☐ check non-restricted refined types in interpreter

examples:
    ☐ add unit tests
    ☐ Update all the examples from changing the grammar

others:
    ☐ inference of the hole @high
        this can be done after typechecking
    ✔ reorganize program modules @done(20-05-21 18:20)
    ☐ inference of type applications
        can be done during typechecking, but need to be careful not to mess up
        everything else
    ☐ change all the hardcoded instances of `-->`, `&&`, `||`, `==` and `And` 
    ✔ update syntax highlighter (create a new git) @done(20-05-21 18:20)


===============================================================================
Done:
    automatic:
        ✔ error when generating a program with no input method parameters @done(20-05-09 19:12)
        ✔ I suspect I forgot to update the evaluation context with the program functions @done(20-05-09 19:12)
            sometimes a random error raises in the interpreter when evaluating the program
            Exception: function not in context
        ✔ make tests stop after 5 seconds @done(20-05-09 19:33)
            way to do this
            @link(https://stackoverflow.com/questions/492519/timeout-on-a-function-call)
        
    synthesis:

    typechecker:

    libraries:
        ✔ add function conversion from int to float @done(20-05-10 19:06)
        ✔ uninterpreted function for `String` size @done(20-05-10 19:09)
        ✔ default function for `Void` that is `None` @done(20-05-10 19:18)
        ✔ improve refinements of String methods @done(20-05-10 19:35)

    frontend:
        ✔ refine strings in frontend @done(20-05-10 22:59)
        ✘ raise warning when conditions are always true/false @cancelled(20-05-13 09:24)
            should actually be check in the typechecker and not frontend

    compiler:

    translator:

    others:
        ✔ python logger @done(20-05-12 10:05)
        ✔ Translator from AeonCore to Aeon @done(20-05-13 12:06)